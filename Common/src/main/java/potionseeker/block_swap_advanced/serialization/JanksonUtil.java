package potionseeker.block_swap_advanced.serialization;

import blue.endless.jankson.Jankson;
import blue.endless.jankson.JsonElement;
import blue.endless.jankson.JsonObject;
import blue.endless.jankson.api.DeserializationException;
import blue.endless.jankson.api.SyntaxError;
import com.google.common.collect.ImmutableMap;
import com.mojang.serialization.Codec;
import com.mojang.serialization.DataResult;
import com.mojang.serialization.DynamicOps;
import potionseeker.block_swap_advanced.BlockSwap;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Map;

public class JanksonUtil {
    public static final String HEADER_CLOSED = """
        // This file was generated by Block Swap Advanced.
        // Do not edit unless you know what you are doing!
        """;

    public static <T> T readConfig(Path path, Codec<T> codec, DynamicOps<com.google.gson.JsonElement> ops) throws IOException, DeserializationException {
        try {
            String jsonString = Files.readString(path);
            JsonElement jsonElement = Jankson.builder().build().load(jsonString);
            com.google.gson.JsonElement gsonElement = com.google.gson.JsonParser.parseString(jsonElement.toJson(false, false));
            BlockSwap.LOGGER.debug("Parsed JSON from {}: {}", path, gsonElement);
            DataResult<T> result = codec.parse(ops, gsonElement);
            if (result.error().isPresent()) {
                throw new DeserializationException(result.error().get().message());
            }
            T config = result.result().get();
            BlockSwap.LOGGER.debug("Deserialized config: {}", config);
            return config;
        } catch (SyntaxError e) {
            throw new DeserializationException("Syntax error in JSON5 file: " + e.getMessage());
        }
    }

    public static <T> DataResult<T> readConfigWithResult(Path path, Codec<T> codec, DynamicOps<com.google.gson.JsonElement> ops) {
        try {
            String jsonString = Files.readString(path);
            JsonElement jsonElement = Jankson.builder().build().load(jsonString);
            com.google.gson.JsonElement gsonElement = com.google.gson.JsonParser.parseString(jsonElement.toJson(false, false));
            BlockSwap.LOGGER.debug("Parsed JSON from {}: {}", path, gsonElement);
            DataResult<T> result = codec.parse(ops, gsonElement);
            if (result.result().isPresent()) {
                BlockSwap.LOGGER.debug("Deserialized config: {}", result.result().get());
            } else if (result.error().isPresent()) {
                BlockSwap.LOGGER.error("Failed to parse config: {}", result.error().get().message());
            }
            return result;
        } catch (IOException e) {
            return DataResult.error(() -> "Failed to read JSON5 file: " + e.getMessage());
        } catch (SyntaxError e) {
            return DataResult.error(() -> "Syntax error in JSON5 file: " + e.getMessage());
        } catch (Exception e) {
            return DataResult.error(() -> "Unexpected error parsing JSON5 file: " + e.getMessage());
        }
    }

    public static <T> void createConfig(Path path, Codec<T> codec, String header, Map<String, String> comments, DynamicOps<com.google.gson.JsonElement> ops, T instance) {
        try {
            DataResult<com.google.gson.JsonElement> result = codec.encodeStart(ops, instance);
            if (result.error().isPresent()) {
                BlockSwap.LOGGER.error("Failed to encode config: {}", result.error().get().message());
                return;
            }
            com.google.gson.JsonElement jsonElement = result.result().get();
            Files.createDirectories(path.getParent());
            String jsonString = new com.google.gson.GsonBuilder().setPrettyPrinting().create().toJson(jsonElement);
            StringBuilder output = new StringBuilder(header + "\n");
            if (!comments.isEmpty()) {
                output.append("// Comments:\n");
                comments.forEach((key, value) -> output.append("// ").append(key).append(": ").append(value).append("\n"));
            }
            output.append(jsonString);
            Files.write(path, output.toString().getBytes());
            BlockSwap.LOGGER.debug("Wrote config to {}: {}", path, jsonString);
        } catch (IOException e) {
            BlockSwap.LOGGER.error("Failed to write config to {}: {}", path, e.getMessage());
        }
    }
}